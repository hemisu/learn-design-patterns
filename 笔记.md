- 设计模式： 在面向对象软件设计中针对特定问题的简洁而优雅的解决方案。

给模式取名，方便与他人交流。

设计模式的作用是让人们写出可复用和可维护性高的程序

“鸭子类型”：指导我们只关注对象的行为，而不关注对象本身，就是关注HAS-A，而不是IS-A

- 多态： 同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。在js中，编译过程中没有类型检查的过程，比如某种动物能否发出叫声，只取决于它有没有makeSound方法，而不取决于它是否是某种类型的对象，不存在任何的“类型耦合”。

多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。

- 封装：目的是将信息隐藏，不仅封装数据和封装实现，还包括封装类型和封装变化。

```js
var myObject = (function (){
  var __name = 'sven'; // 私有变量
  return {
    getName: function() { // 公开方法
      return __name;
    }
  }
})
// 也可以用symbol
```

基于原型链的委托机制就是原型继承的本质。当对象无法响应某个请求时，会把该请求委托给自己的原型。
原型编程范式：
- 所有的数据都是对象
- 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并且克隆它
- 对象会记住它的原型
- 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型

javascript的函数既可以作为普通函数被调用，也可以作为函数构造器被调用。

3.1.6 闭包与内存管理
跟闭包和内存泄漏有关的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄漏。但这本身并非闭包的问题，也并非JavaScript的问题。在IE浏览器中的BOM和DOM对象使用的是C++以COM对象的方式实现的，而COM对象的垃圾回收机制采用的是引用计数策略。

3.2 高阶函数
- 函数可以作为参数
- 函数可以作为返回值

3.2.3 高阶函数实现AOP
AOP（面向切面编程） 把一些跟核心业务逻辑模块无关的功能抽离出来。

## 单例模式
核心： 确保只有一个实例，并提供全局访问

```js
var ProxySingletonCreateDiv = (function() {
  var instance;
  return function() {
    if (!instance) {
      instance = new CreateDiv(html); // 创建一个实例
    }

    return instance;
  }
})
```

### 减少全局变量带来的命名污染:
- 使用命名空间
```js
var namespace1 = {
  a: function() {
    alert(1);
  },
  b: function() {
    alert(2);
  },
}
```
- 使用闭包封装私有变量
```js
var user = (function() {
  var __name = 'sevn',
      __age = 20;
  return {
    getUserInfo: function() {
      return __name + '-' + __age;
    }
  }
})
```

## 策略模式
定义： 定义一系列的算法，把它们一个个封装起来，并且可以使它们可以相互替换。

通俗点来说，就是定义一系列的算法，把它们各自封装成策略类，算法被封装在策略类内部的方法里。在客户对context发起请求的时候，context总是把请求委托给这些策略对象中间的某一个进行计算。

基于策略模式的程序由两部分组成：策略类和环境类

- 策略类封装了具体的算法，并且负责具体的计算过程。
- 环境类接受客户的请求，随后把请求委托给某一策略类。

环境类保持着对某个策略对象的引用。

文件5.html 5.6.html中提供了计算奖金、缓动动画、表单校验三种例子。

策略模式的优缺点：
- 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。
- 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立strategy中，使得它易于切换，易于理解，易于拓展。
- 在策略模式中利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种替代方案。

在函数作为一等对象的语言中，策略模式是隐形的。strategy就是值为函数的变量。
可以通过高阶函数来封装不同的行为，并且把它传递到另一个函数中。

比如计算奖金的实现 我们就可以使用：
```js
var S = (salary) => salary * 4;
var A = (salary) => salary * 3;
var B = (salary) => salary * 2;

var calculateBonus = (func, salary) => func(salary);

console.log(calculateBonus(S, 1000));
```

## 代理模式
代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。

代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候。提供一个替身对象来的控制对这个对象的访问，客户实际上访问的是替身对象。

书中举例小明追女神的故事
小明 -> A
小明 -> B -> A

保护代理：比如B代理可以帮忙筛选掉一些年龄太大的或者没有钱的

虚拟代理：比如创建Flower开销很大的话，可以考虑在B中创建这个对象。

保护代理用于控制不同权限的对象对目标对象的访问，但是在JavaScript中不容易实现保护代理，因为我们无法判断谁访问了这个对象。
虚拟代理是最常用的一种代理模式。

代理和本体接口的一致性：
- 用户可以放心地请求代理，他只关心是否能得到想要的结果
- 在任何使用本体的地方都可以替换成使用代理

> 需要注意的是 如果代理对象和本体对象都为一个函数，函数必然都能被执行，则可以认为它们也是具有一致的"接口".

单一职责： 一个类（通常包括对象和函数等），应该仅有一个引起它变化的原因。


example:
- 虚拟代理实现图片预加载
- 虚拟代理合并HTTP请求
- 虚拟代理可以用来惰性加载（如例子里miniConsole)
- 缓存代理（可以保存之前计算过的值）


## 迭代器模式
定义： 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。

迭代器分为：
- 内部迭代器
- 外部迭代器

内部迭代器定义好了迭代规则，完全接手了整个迭代过程，外部只需要一次初始调用。
如果需要对比两个数组里的元素是否相等，如果不改写each函数本身的代码，就只能去修改回调函数callback的值。

外部迭代器必须显示地请求迭代下一个元素。

书中举例，有三种上传文件的方式，但是不知道浏览器支持哪个，可以通过使用迭代器的方法，写出如下迭代参数的内部迭代器：

```js
var getActiveUoloadObj = function() {
  try {
    return new ActiveXObject('TXFNActiveX.FNUpload');
  } catch(e) {
    return false;
  }
}
var getFlashUploadObj = function() {
  if(supportFlash()) {
    var str = '<object type="application/x-shockwave-flash"></object>';
    return $(str).appendTo($('body'));
  }
}

var getFormUploadObj = function() {
  var str = '<input name="file" type="file" class="ui-file" />';
  return $(str).appendTo($('body'));
}

var iteratorUploadObj = function() {
  for(var i = 0, fn; fn = arguments[i++];) {
    var uploadObj = fn();
    if(uploadObj !== false) {
      return uploadObj;
    }
  }
}

var uploadObj = iteratorUploadObj(
  getActiveUoloadObj, // IE上传控件
  getFlashUploadObj, // flash上传控件
  getFormUploadObj, // 表单上传控件
)
```

如果之后又添加了webkit控件和html5上传对象，可以再添加到迭代器参数中。

## 发布-订阅模式
发布-订阅模式又叫观察者模式，它定义对象之间一种一对多的依赖关系。当一个对象的状态发生变化时，所有依赖于它的对象都将得到通知。

### 作用
- 可以广泛应用于异步编程，代替传递回调函数
- 可以取代对象之间硬编码的通知机制

### 如何实现（其实这是一个观察者模式）
- 制定好谁当发布者
- 给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者
- 发布消息的时候，发布者会遍历缓存列表，依次触发存放在里面的回调函数（用回调函数替代订阅对象.update这种形式）

文中举例了售楼处、购房者这一对订阅关系

真实的例子比如用户登录之后，会修改header、nav、消息列表、购物车等

另外还需要思考一个问题，必须要先订阅再发布吗？
我们可以建立一个离线事件的堆栈，当事件发布的时候，如果还没有订阅者来订阅这个事件，就暂时把发布事件的动作包裹在一个函数里，这些包装函数将被存入堆栈中，等到有对象来订阅此事件时，遍历堆栈并且依次执行

书中提供的带有离线消息和命名空间的Event对象放在8.js中


## 命令模式

应用场景： 需要向某些对象发送请求，但是不知道请求的接受者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计软件，使得请求发送者和请求接受者能消除彼此之间的耦合关系。

举个例子，拿订餐来说，客人需要向厨师发送请求，但是不知道有哪些厨师。这时候就可以用菜单点餐，把订餐的请求封装成Command对象，这个对象就可以被四处传递。

在传统面向对象语言中，无法直接传递函数。
所以需要把请求封装在Command对象的execute方法里。吧把命令都封装在一个command对象中，可以直接执行。

对比策略模式，不依赖接受者的“聪明式”的命令对象十分相似。但是两者的区别在于，策略模式最终实现的目的是相似的，只是用了不同的算法去达到同样的目的；而命令模式中的“聪明式”的命令对象则是可以实现不同的目的，比如add,redo这种。

### 宏命令
宏命令是一组集合的组合，通过执行宏命令的形式，可以一次执行一批命令。

### 智能命令和傻瓜命令

## 组合模式
组合模式是一种Has-a的聚合，将对象组合成树形结构，以表示“部分-整体”的层次结构。

另外组合模式的另外一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。

对比宏命令来说，宏命令表现的像是一组命令的代理，并非真正的代理。它只负责将请求传递给叶对象，目的不在于控制对叶对象的访问。


例子比如像文件的扫描

### 需要注意的地方
1. 组合模式不是父子关系 组合对象是把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有相同的接口。
2. 对叶对象的操作一致性
3. 双向映射关系
4. 天然形成一个父对子的职责链的关系： 如果要设置子对父的，参考文件删除（需要在找到父节点删除子元素）

## 模板方式
coffe&tea
子类实现中的相同部分被上移到父类中，在子类中没有init方法，会委托到父类原型之上。

> 抽象类和具体类都可以用于向上转型，但是具体类可以被实例化。在抽象类中可以有抽象方法和具体方法。

### 好莱坞原则
不要自己执行，我们需要的时候会找你

体现这个原则的模式有：
- 模板方法
- 发布-订阅模式
- 回调函数

## 享元模式
例子：
1. 50个男模特，50个女模特换衣服
2. 文件上传
3. 地图上的红标点

当系统中创建了大量相似的对象，并且他们的内部状态相对较少（例如例子1的男、女，例子2的上传方式），就可以使用

### 通用对象池的实现
```js
var objectPoolFactory = function(createObjFn) {
  var objectPool = [];

  return {
    create: function() {
      var obj = objectPool.length === 0 ?
        createObjFn.apply(this, arguments) : objectPool.shift();

        return obj;
    },
    recover: function(obj) {
      objectPool.push(obj);
    }
  }
}
```


